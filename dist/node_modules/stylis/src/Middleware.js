import { RULESET as g, KEYFRAMES as x, DECLARATION as $, WEBKIT as w, MOZ as n, MS as y } from "./Enum.js";
import { combine as A, replace as u, sizeof as M, match as R, assign as h, filter as E } from "./Utility.js";
import { copy as i, lift as t } from "./Tokenizer.js";
import { serialize as S } from "./Serializer.js";
import { prefix as T } from "./Prefixer.js";
function B(r) {
  var o = M(r);
  return function(f, s, p, d) {
    for (var c = "", a = 0; a < o; a++)
      c += r[a](f, s, p, d) || "";
    return c;
  };
}
function C(r) {
  return function(o) {
    o.root || (o = o.return) && r(o);
  };
}
function D(r, o, f, s) {
  if (r.length > -1 && !r.return)
    switch (r.type) {
      case $:
        r.return = T(r.value, r.length, f);
        return;
      case x:
        return S([i(r, { value: u(r.value, "@", "@" + w) })], s);
      case g:
        if (r.length)
          return A(f = r.props, function(p) {
            switch (R(p, s = /(::plac\w+|:read-\w+)/)) {
              // :read-(only|write)
              case ":read-only":
              case ":read-write":
                t(i(r, { props: [u(p, /:(read-\w+)/, ":" + n + "$1")] })), t(i(r, { props: [p] })), h(r, { props: E(f, s) });
                break;
              // :placeholder
              case "::placeholder":
                t(i(r, { props: [u(p, /:(plac\w+)/, ":" + w + "input-$1")] })), t(i(r, { props: [u(p, /:(plac\w+)/, ":" + n + "$1")] })), t(i(r, { props: [u(p, /:(plac\w+)/, y + "input-$1")] })), t(i(r, { props: [p] })), h(r, { props: E(f, s) });
                break;
            }
            return "";
          });
    }
}
export {
  B as middleware,
  D as prefixer,
  C as rulesheet
};
//# sourceMappingURL=Middleware.js.map
